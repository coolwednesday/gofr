# Discord Release Notification Workflow
# 
# This workflow sends release notes to Discord when a new release is published.
# 
# Setup:
# 1. Create a Discord webhook URL in your Discord server settings
# 2. Add the webhook URL as a secret named "DISCORD_WEBHOOK" in your GitHub repository
#    (Settings -> Secrets and variables -> Actions -> New repository secret)
# 
# Features:
# - Automatically splits long release notes into multiple messages (Discord has a 2000 char limit)
# - Preserves formatting and line breaks
# - Includes release tag, name, and link in the notification

name: Discord Release Notification

on:
  release:
    types: [published]

jobs:
  notify-discord:
    name: Send Release Notes to Discord
    runs-on: ubuntu-latest
    steps:
      - name: Send Release Notes to Discord
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          RELEASE_NAME: ${{ github.event.release.name }}
          RELEASE_BODY: ${{ github.event.release.body }}
          RELEASE_URL: ${{ github.event.release.html_url }}
        run: |
          # Function to send a message to Discord
          send_discord_message() {
            local content="$1"
            local content_length=${#content}
            echo "üì§ Sending message (length: $content_length chars)..."
            
            # Check if content exceeds Discord limit
            if [ $content_length -gt 2000 ]; then
              echo "‚ö†Ô∏è  WARNING: Message exceeds 2000 chars! Discord will reject it."
            fi
            
            # Use jq to properly encode content as JSON
            local json_payload=$(echo "$content" | jq -Rs . | jq -c '{content: .}')
            
            # Send to Discord and capture response
            response=$(curl -s -w "\n%{http_code}" -H "Content-Type: application/json" \
              -X POST \
              -d "$json_payload" \
              "$DISCORD_WEBHOOK")
            
            http_code=$(echo "$response" | tail -n1)
            response_body=$(echo "$response" | head -n-1)
            
            if [ "$http_code" = "204" ] || [ "$http_code" = "200" ]; then
              echo "‚úÖ Message sent successfully (HTTP $http_code)"
              return 0
            else
              echo "‚ùå Failed to send message (HTTP $http_code)"
              echo "Response: $response_body"
              return 1
            fi
            echo ""
          }
          
          # Create the release notification header with @everyone mention
          # Make the heading prominent and suppress embed preview
          VERSION="$RELEASE_TAG"
          
          # Use $'...' syntax for proper newline interpretation
          # Wrap URL in <> to suppress Discord's embed preview
          header=$'@everyone\n\n'
          header+=$'# üåü **GoFr '"$VERSION"$' Released!** üåü\n'
          header+=$'<'"$RELEASE_URL"$'>\n'
          
          # Get release notes
          release_notes="$RELEASE_BODY"
          
          # If release notes are empty, use a default message
          if [ -z "$release_notes" ] || [ "$release_notes" = "null" ]; then
            release_notes="No release notes provided."
          else
            # Remove the first H1 or H2 heading from release notes (it's redundant)
            # This removes lines starting with # or ## (with optional spaces)
            release_notes=$(echo "$release_notes" | sed '1{/^##\? /d;}')
            # Also remove any leading empty lines
            release_notes=$(echo "$release_notes" | sed '/./,$!d')
            
            # Convert markdown headers to Discord-friendly format with proper hierarchy
            # Discord doesn't render ### and #### well, so convert with visual distinction
            # ### Header -> **__Header__** with blank line after (bold + underline for main sections)
            release_notes=$(echo "$release_notes" | sed 's/^### \(.*\)$/\n**__\1__**\n/g')
            # #### Header -> **Header** with blank line after (just bold for sub-sections)
            release_notes=$(echo "$release_notes" | sed 's/^#### \(.*\)$/\n**\1**\n/g')
          fi
          
          # Combine header and release notes
          full_message="${header}${release_notes}"
          
          # Discord's message limit is 2000 characters
          MAX_LENGTH=2000
          CHUNK_SIZE=1950  # Default chunk size
          
          # Calculate header length and adjust first chunk size
          header_length=${#header}
          FIRST_CHUNK_SIZE=$((MAX_LENGTH - header_length - 50))  # 50 char safety buffer
          
          echo "üìä Full message length: ${#full_message} chars (limit: $MAX_LENGTH)"
          echo "üìè Header length: $header_length chars, First chunk limit: $FIRST_CHUNK_SIZE chars"
          
          # Check if message exceeds Discord's limit
          if [ ${#full_message} -le $MAX_LENGTH ]; then
            # Send as single message
            echo "‚úâÔ∏è  Sending as single message..."
            send_discord_message "$full_message"
          else
            echo "‚úÇÔ∏è  Message exceeds limit, splitting into chunks..."
            # Split release notes into chunks
            # Use a temporary file to handle the splitting properly
            temp_file=$(mktemp)
            echo "$release_notes" > "$temp_file"
            
            chunk_num=1
            current_chunk=""
            is_first_chunk=true
            current_chunk_limit=$FIRST_CHUNK_SIZE  # Start with smaller limit for first chunk
            
            # Read line by line to preserve formatting
            while IFS= read -r line || [ -n "$line" ]; do
              # Calculate what the chunk would look like with this line
              if [ -z "$current_chunk" ]; then
                test_chunk="$line"
              else
                test_chunk="$current_chunk"$'\n'"$line"
              fi
              
              # If adding this line would exceed the current chunk limit
              if [ ${#test_chunk} -gt $current_chunk_limit ]; then
                # Send current chunk if it has content
                if [ -n "$current_chunk" ]; then
                  # Add header only to first chunk
                  if [ "$is_first_chunk" = true ]; then
                    send_discord_message "${header}${current_chunk}"
                    is_first_chunk=false
                    current_chunk_limit=$CHUNK_SIZE  # Switch to normal chunk size after first
                  else
                    send_discord_message "$current_chunk"
                  fi
                  chunk_num=$((chunk_num + 1))
                  sleep 0.5  # Small delay to avoid rate limiting
                fi
                
                # If the line itself is too long, split it by words
                if [ ${#line} -gt $current_chunk_limit ]; then
                  # Function to find last space character position (UTF-8 safe)
                  find_last_space_char_pos() {
                    local str="$1"
                    local len=${#str}
                    local pos=-1
                    # Search backwards through character positions
                    for ((i=len-1; i>=0; i--)); do
                      if [ "${str:$i:1}" = " " ]; then
                        pos=$i
                        break
                      fi
                    done
                    echo "$pos"
                  }
                  
                  # Split long line by spaces, trying to keep words together
                  remaining_line="$line"
                  MIN_CHUNK_SIZE=100  # Minimum chunk size to avoid very small chunks
                  while [ ${#remaining_line} -gt $current_chunk_limit ]; do
                    # Find the last space within the chunk size (character-based search)
                    chunk_part="${remaining_line:0:$current_chunk_limit}"
                    last_space_char_pos=$(find_last_space_char_pos "$chunk_part")
                    
                    if [ "$last_space_char_pos" -ge 0 ]; then
                      # Use the space if it results in a chunk of reasonable size
                      break_point=$((last_space_char_pos + 1))  # +1 to include the space
                      if [ "$break_point" -ge $MIN_CHUNK_SIZE ]; then
                        chunk_part="${remaining_line:0:$break_point}"
                        remaining_line="${remaining_line:$break_point}"
                        # Remove leading space if present
                        remaining_line="${remaining_line# }"
                      else
                        # Space too close to start, force break at current limit
                        chunk_part="${remaining_line:0:$current_chunk_limit}"
                        remaining_line="${remaining_line:$current_chunk_limit}"
                      fi
                    else
                      # Force break if no space found
                      chunk_part="${remaining_line:0:$current_chunk_limit}"
                      remaining_line="${remaining_line:$current_chunk_limit}"
                    fi
                    
                    # Add header only to first chunk
                    if [ "$is_first_chunk" = true ]; then
                      send_discord_message "${header}${chunk_part}"
                      is_first_chunk=false
                      current_chunk_limit=$CHUNK_SIZE  # Switch to normal chunk size after first
                    else
                      send_discord_message "$chunk_part"
                    fi
                    chunk_num=$((chunk_num + 1))
                    sleep 0.5
                  done
                  current_chunk="$remaining_line"
                else
                  current_chunk="$line"
                fi
              else
                # Add line to current chunk
                if [ -z "$current_chunk" ]; then
                  current_chunk="$line"
                else
                  current_chunk="$current_chunk"$'\n'"$line"
                fi
              fi
            done < "$temp_file"
            
            # Send remaining chunk
            if [ -n "$current_chunk" ]; then
              # Add header only to first chunk
              if [ "$is_first_chunk" = true ]; then
                send_discord_message "${header}${current_chunk}"
              else
                send_discord_message "$current_chunk"
              fi
            fi
            
            # Clean up
            rm -f "$temp_file"
          fi


